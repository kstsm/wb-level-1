package main

import (
	"fmt"
	"math/rand"
	"os"
	"strconv"
	"sync"
	"time"
)

//Реализовать постоянную запись данных в канал (в главной горутине).
//Реализовать набор из N воркеров, которые читают данные из этого канала и выводят их в stdout.
//Программа должна принимать параметром количество воркеров и при старте создавать указанное число горутин-воркеров.

// Worker функция, выполняемая каждой горутиной-воркером
func worker(i int, ch <-chan int, wg *sync.WaitGroup) {
	// Уменьшаем счётчик WaitGroup при завершении работы
	defer wg.Done()

	// Читаем числа из канала до его закрытия
	for num := range ch {
		fmt.Printf("Воркер %d получил число: %d\n", i, num)
	}
}

func main() {
	// Создаём канал для передачи целых чисел
	ch := make(chan int)
	// Создаём WaitGroup для ожидания завершения воркеров
	var wg sync.WaitGroup

	// Проверяем наличие аргумента командной строки
	if len(os.Args) < 2 {
		fmt.Println("Вести go run main.go <количество воркеров>")
		return
	}

	// Преобразуем в число
	work, err := strconv.Atoi(os.Args[1])
	if err != nil || work <= 0 {
		fmt.Println("Вести положительное целое число для количества воркеров")
		return
	}

	// Устанавливаем счётчик WaitGroup равным количеству воркеров
	wg.Add(work)

	// Запускаем указанное количество воркеров
	for i := 0; i < work; i++ {
		go worker(i, ch, &wg)
	}

	// Запускаем горутину для записи случайных чисел в канал
	go func() {
		// Бесконечный цикл записи в канал
		for {
			// Отправляем случайное число от 0 до 99
			ch <- rand.Intn(100)
			// Пауза 1 секунда между отправками
			time.Sleep(time.Second)
		}
	}()

	// Ожидаем завершения всех воркеров (Это не произойдет т.к. они будут работать бесконечно)
	wg.Wait()
}
