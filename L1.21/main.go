package main

import "fmt"

//Реализовать паттерн проектирования «Адаптер» на любом примере.
//Описание: паттерн Adapter позволяет сконвертировать интерфейс одного класса в интерфейс другого,
//который ожидает клиент. Продемонстрируйте на простом примере в Go: у вас есть существующий интерфейс
//(или структура) и другой, несовместимый по интерфейсу потребитель — напишите адаптер, который реализует
//нужный интерфейс и делегирует вызовы к встроенному объекту.
//Поясните применимость паттерна, его плюсы и минусы, а также приведите реальные примеры использования.

// Когда используется?
// Когда нужно использовать существующий класс, но его интерфейс не совместим с остальным кодом
// Когда нужно интегрировать сторонние библиотеки или API
// Когда нужно обеспечить работу нескольких классов с разными интерфейсами

// Плюсы:
// Позволяет использовать старый код без его переписывания
// Легко заменить одну реализацию на другую
// Упрощает интеграцию разных систем и библиотек

// Минусы:
// Усложнение кода за счет дополнительной абстракции
// Дополнительные вызовы могут незначительно снизить производительность

// Реальные примеры использования:
// Замена библиотеки без переписывания кода через адаптер. Как сделано у меня в коде,
// где я заменил одну базу данных на другую, не трогая мой нынешний код

// Repo это новый интерфейс, с которым работает клиентский код
// Клиент ожидает метод SaveOrder, и именно через этот интерфейс он будет работать
type Repo interface {
	SaveOrder(id int)
}

// OldSQL "старый" код, который менять нельзя
// У него другой метод с несовместимым именем: OldSaveOrder
type OldSQL struct{}

func (o *OldSQL) OldSaveOrder(id int) {
	fmt.Println("Сохранение заказа под номером:", id)
}

// SQLAdapter адаптер, который оборачивает OldSQL
// Он, реализует интерфейс Repo и делегирует вызовы старому коду
type SQLAdapter struct {
	oldSQL *OldSQL
}

// SaveOrder реализация метода интерфейса Repo
// Вместо своей логики он вызывает OldSaveOrder у встроенного объекта
func (a *SQLAdapter) SaveOrder(id int) {
	a.oldSQL.OldSaveOrder(id)
}

// NewSQLAdapter конструктор, который возвращает адаптер
// Клиент получает интерфейс Repo, а не конкретный тип SQLAdapter
func NewSQLAdapter(old *OldSQL) Repo {
	return &SQLAdapter{oldSQL: old}
}

func main() {
	// Объявили репозиторий через конструктор
	repo := NewSQLAdapter(&OldSQL{})
	// Благодаря адаптеру мы можем использовать OldSaveOrder
	repo.SaveOrder(2)
}
